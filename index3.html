<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Pendant Configurator with Patterns</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
        }

        canvas {
            display: block;
        }

        .controls {
            position: absolute;
            top: 70px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 8px;
            z-index: 1;
            width: 400px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .controls label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .controls label span {
            flex-basis: 60%; /* Adjust as needed for label width */
        }

        .controls input[type=number] {
            border-radius: 3px;
            border: 1px solid #ccc;
            width: 80px; /* Increased width for better input */
            height: 28px;
            padding: 0 8px;
            box-sizing: border-box; /* Include padding in width */
            margin-left: 10px;
        }

        input[type=range] {
            -webkit-appearance: none;
            width: 60%;
            height: 8px;
            background: #e0e0e0;
            border-radius: 4px;
            outline: none;
            flex-grow: 1;
        }

        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            background: #4caf50;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-top: -6px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        select {
            width: 100%;
            height: 38px;
            margin-top: 10px;
            margin-bottom: 20px;
            font-size: 16px;
            border-radius: 6px;
            padding: 4px 8px;
            border: 1px solid #ccc;
            box-sizing: border-box;
            background-color: #f9f9f9;
        }

        .controls p {
            margin-top: 20px;
            margin-bottom: 10px;
            font-weight: bold;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }

        #generate {
            width: 100%;
            height: 45px;
            border: none;
            background-color: #4caf50;
            color: #fff;
            border-radius: 10px;
            margin: 40px 0 10px 0;
            font-size: 18px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #generate:disabled {
            background-color: #a5d6a7;
            cursor: not-allowed;
        }

        #generate:hover:not(:disabled) {
            background-color: #43a047;
        }

        #hamburger {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 30px;
            z-index: 2;
            cursor: pointer;
            background: rgba(255, 255, 255, 0.9);
            padding: 5px 15px;
            border-radius: 5px;
            transition: transform 0.3s ease, background 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        #hamburger.active {
            transform: rotate(90deg);
            background: rgba(255, 255, 255, 1);
        }

        .dimension-label {
            position: absolute;
            color: rgba(0, 0, 0, 0.7);
            background: rgba(255, 255, 255, 0.8);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 13px;
            pointer-events: none; /* Allows clicks to pass through */
            white-space: nowrap;
            transform: translate(-50%, -50%); /* Center the label */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        /* Responsive design for smaller screens */
        @media (max-width: 768px) {
            .controls {
                width: calc(100% - 40px);
                left: 20px;
                right: 20px;
                top: 60px; /* Adjust top for hamburger */
                padding: 10px;
            }

            .controls label {
                flex-direction: column;
                align-items: flex-start;
            }

            .controls label span {
                margin-bottom: 5px;
            }

            input[type=range] {
                width: 100%;
                margin-bottom: 15px;
            }

            .controls input[type=number] {
                width: 100%;
                margin-top: 5px;
                margin-left: 0;
            }

            #hamburger {
                top: 10px;
                left: 10px;
                font-size: 24px;
                padding: 3px 12px;
            }
        }
    </style>
</head>

<body>
    <div id="hamburger">â˜°</div>
    <div class="controls">
        <label>Pattern:
            <select id="pattern">
                <option value="flat">Flat</option>
                <option value="wave">Wave</option>
                <option value="ripple">Ripple</option>
                <option value="diagonal">Diagonal</option>
                <option value="checkerboard">Checkerboard</option>
                <option value="pyramid">Pyramid</option>
                <option value="inverted-pyramid">Inverted Pyramid</option>
                <option value="grid-step">Grid Step</option>
                <option value="radial-step">Radial Step</option>
                <option value="random">Random</option>
                <option value="clustered-peaks">Clustered Peaks</option>
                <option value="noise">Noise</option>
                <option value="biased-random">Biased Random</option>
                <option value="spiral">Spiral</option>
                <option value="stairs">Stairs</option>
                <option value="mirror">Mirror</option>
                <option value="zigzag">Zigzag</option>
                <option value="bowl">Bowl</option>
                <option value="dome">Dome</option>
                <option value="wavefront">Wavefront</option>
            </select>
        </label>
        <label>Rows:
            <input type="range" min="1" max="20" value="8" id="rowsRange">
            <input type="number" id="rows" min="1" max="20" value="8">
        </label>
        <label>Columns:
            <input type="range" min="1" max="20" value="8" id="columnsRange">
            <input type="number" id="columns" min="1" max="20" value="8">
        </label>
        <p>Composition Dimensions</p>
        <label>Surface Length:
            <input type="range" min="1" max="1000" value="200" id="surfaceLengthRange">
            <input type="number" id="surfaceLength" min="1" max="1000" value="200">
        </label>
        <label>Surface Width:
            <input type="range" min="1" max="1000" value="200" id="surfaceWidthRange">
            <input type="number" id="surfaceWidth" min="1" max="1000" value="200">
        </label>
        <label>Surface Height:
            <input type="range" min="1" max="1000" value="150" id="surfaceHeightRange">
            <input type="number" id="surfaceHeight" min="1" max="1000" value="150">
        </label>
        <label>Spacing:
            <input type="range" min="1" max="100" value="35" id="spacingRange">
            <input type="number" id="spacing" min="1" max="100" value="35">
        </label>
        <label>Lowest From Ground:
            <input type="range" min="1" max="1000" value="0" id="lowestRange">
            <input type="number" id="lowest" min="1" max="1000" value="0">
        </label>
        <label>Highest From Ground:
            <input type="range" min="1" max="1000" value="100" id="highestRange">
            <input type="number" id="highest" min="1" max="1000" value="100">
        </label>
        <button id="generate" disabled>Generate Grid</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>

    <script>
        // --- THREE.js Scene Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x9e9e9e);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 200, 300); // Adjusted camera initial position for better view
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 100, 0); // Target slightly above ground for better orbit

        // Lighting
        scene.add(new THREE.AmbientLight(0xffffff, 0.6)); // Increased ambient light intensity
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); // Adjusted intensity
        directionalLight.position.set(100, 200, 150); // More distinct light source
        scene.add(directionalLight);

        // --- Global Variables ---
        let pendantModel = null;
        let surfaceMesh = null;
        const pendantStrings = [];
        const dimensionLines = [];
        const dimensionLabels = [];

        // --- Constants ---
        const PENDANT_SCALE = 5;
        const STRING_RADIUS = 0.2;
        const STRING_SEGMENTS = 8;
        const STRING_COLOR = 0x222222;
        const SURFACE_COLOR = 0x555555;
        const DIMENSION_LINE_COLOR = 0x000000;

        // --- DOM Elements ---
        const generateButton = document.getElementById('generate');
        const hamburger = document.getElementById('hamburger');
        const controlsPanel = document.querySelector('.controls');

        // Input elements
        const patternSelect = document.getElementById('pattern');
        const rowsRange = document.getElementById('rowsRange');
        const rowsInput = document.getElementById('rows');
        const columnsRange = document.getElementById('columnsRange');
        const columnsInput = document.getElementById('columns');
        const surfaceLengthRange = document.getElementById('surfaceLengthRange');
        const surfaceLengthInput = document.getElementById('surfaceLength');
        const surfaceWidthRange = document.getElementById('surfaceWidthRange');
        const surfaceWidthInput = document.getElementById('surfaceWidth');
        const surfaceHeightRange = document.getElementById('surfaceHeightRange');
        const surfaceHeightInput = document.getElementById('surfaceHeight');
        const spacingRange = document.getElementById('spacingRange');
        const spacingInput = document.getElementById('spacing');
        const lowestRange = document.getElementById('lowestRange');
        const lowestInput = document.getElementById('lowest');
        const highestRange = document.getElementById('highestRange');
        const highestInput = document.getElementById('highest');

        // --- Model Loading ---
        const objLoader = new THREE.OBJLoader();
        objLoader.load('models/myModel.obj', (obj) => {
            pendantModel = obj;
            generateButton.disabled = false;
        }, undefined, (error) => {
            console.error('An error occurred loading the OBJ model:', error);
            alert("Failed to load pendant model. Please check the model path.");
        });

        // --- Scene Management Functions ---
        function clearScene() {
            // Remove pendants and strings
            scene.children = scene.children.filter(obj => !obj.userData.isPendant && obj !== surfaceMesh && !pendantStrings.includes(obj));
            pendantStrings.length = 0; // Clear the array

            // Clear dimension lines and labels
            clearDimensionLines();
        }

        function clearDimensionLines() {
            dimensionLines.forEach(line => scene.remove(line));
            dimensionLines.length = 0;

            dimensionLabels.forEach(label => label.remove());
            dimensionLabels.length = 0;
        }

        /**
         * Creates a 3D dimension line and a corresponding 2D HTML label.
         * @param {THREE.Vector3} start - The start point of the line.
         * @param {THREE.Vector3} end - The end point of the line.
         * @param {string} labelText - The text to display in the label.
         */
        function createDimensionLine(start, end, labelText) {
            const material = new THREE.LineBasicMaterial({ color: DIMENSION_LINE_COLOR });
            const points = [start, end];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            dimensionLines.push({ line, start, end }); // Store start/end for updating label

            const div = document.createElement('div');
            div.className = 'dimension-label';
            div.innerHTML = labelText;
            document.body.appendChild(div);
            dimensionLabels.push(div);
        }

        // --- Main Grid Generation Logic ---
        generateButton.addEventListener('click', () => {
            if (!pendantModel) {
                alert("Pendant model not yet loaded. Please wait.");
                return;
            }
            clearScene();

            const rows = parseInt(rowsInput.value);
            const cols = parseInt(columnsInput.value);
            const spacing = parseFloat(spacingInput.value);
            const lowest = parseFloat(lowestInput.value);
            const highest = parseFloat(highestInput.value);
            const surfaceHeight = parseFloat(surfaceHeightInput.value);
            const surfaceLength = parseFloat(surfaceLengthInput.value);
            const surfaceWidth = parseFloat(surfaceWidthInput.value);
            const pattern = patternSelect.value;

            if (surfaceHeight < lowest || surfaceHeight < highest) {
                alert("Invalid configuration: Surface height cannot be less than the lowest or highest pendant positions.");
                return;
            }

            const offsetX = -(cols - 1) * spacing / 2;
            const offsetZ = -(rows - 1) * spacing / 2;
            const pendantBoundingBox = new THREE.Box3().setFromObject(pendantModel.clone());
            const objHeight = pendantBoundingBox.getSize(new THREE.Vector3()).y * PENDANT_SCALE; // Account for scale

            // Add surface
            if (surfaceMesh) scene.remove(surfaceMesh);
            surfaceMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(surfaceWidth, surfaceLength),
                new THREE.MeshStandardMaterial({ color: SURFACE_COLOR, side: THREE.DoubleSide })
            );
            surfaceMesh.rotation.x = -Math.PI / 2;
            surfaceMesh.position.set(0, objHeight + surfaceHeight, 0); // Position surface above pendants
            scene.add(surfaceMesh);

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    let yOffset = 0;
                    const normalizedRow = r / (rows - 1); // 0 to 1
                    const normalizedCol = c / (cols - 1); // 0 to 1
                    const totalProgress = (r + c) / (rows + cols - 2); // For diagonal effects

                    // Common calculations for patterns
                    const heightMidpoint = (lowest + highest) / 2;
                    const heightAmplitude = (highest - lowest) / 2;
                    const centerX = cols / 2;
                    const centerY = rows / 2;
                    const deltaX = c - centerX;
                    const deltaY = r - centerY;
                    const distanceToCenter = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                    switch (pattern) {
                        case 'flat':
                            yOffset = highest; // All pendants at highest level by default
                            break;
                        case 'wave':
                            yOffset = heightMidpoint + (Math.sin(c * 0.5) + Math.cos(r * 0.5)) * heightAmplitude;
                            break;
                        case 'ripple':
                            yOffset = heightMidpoint + Math.sin(distanceToCenter * 0.7) * heightAmplitude;
                            break;
                        case 'diagonal':
                            yOffset = lowest + (highest - lowest) * totalProgress;
                            break;
                        case 'checkerboard':
                            yOffset = ((r + c) % 2 === 0) ? highest : lowest;
                            break;
                        case 'pyramid':
                            // Inverted distance (peak at center, lowest at edges)
                            yOffset = highest - (distanceToCenter * (highest - lowest) / Math.max(centerX, centerY));
                            break;
                        case 'inverted-pyramid':
                            // Distance (lowest at center, highest at edges)
                            yOffset = lowest + (distanceToCenter * (highest - lowest) / Math.max(centerX, centerY));
                            break;
                        case 'grid-step':
                            yOffset = lowest + (r + c) * ((highest - lowest) / (rows + cols - 2));
                            break;
                        case 'radial-step':
                            yOffset = lowest + Math.floor(distanceToCenter) * ((highest - lowest) / Math.max(centerX, centerY));
                            break;
                        case 'clustered-peaks':
                            const cluster1Dist = Math.sqrt((deltaX - 1) ** 2 + (deltaY - 1) ** 2);
                            const cluster2Dist = Math.sqrt((deltaX + 1) ** 2 + (deltaY + 1) ** 2);
                            yOffset = heightMidpoint + (cluster1Dist < 1.5 || cluster2Dist < 1.5 ? heightAmplitude : Math.random() * (highest - lowest) * 0.2);
                            break;
                        case 'noise':
                            yOffset = heightMidpoint + (Math.sin(c * 1.3 + r * 0.7) + Math.cos(r * 1.1)) * (heightAmplitude * 0.5);
                            break;
                        case 'biased-random':
                            yOffset = lowest + Math.pow(Math.random(), 2) * (highest - lowest);
                            break;
                        case 'spiral':
                            const angle = Math.atan2(deltaY, deltaX);
                            yOffset = heightMidpoint + (angle / Math.PI * heightAmplitude * 0.5) + (distanceToCenter * heightAmplitude * 0.1);
                            break;
                        case 'stairs':
                            yOffset = lowest + (normalizedRow * (highest - lowest));
                            break;
                        case 'mirror':
                            yOffset = lowest + Math.abs(deltaX) * ((highest - lowest) / centerX);
                            break;
                        case 'zigzag':
                            yOffset = ((r % 2 === 0 && c % 2 === 0) || (r % 2 !== 0 && c % 2 !== 0)) ? highest : lowest;
                            break;
                        case 'bowl':
                            yOffset = highest - (distanceToCenter * distanceToCenter) * (highest - lowest) / (Math.max(centerX, centerY)**2 * 2);
                            yOffset = Math.max(yOffset, lowest); // Ensure it doesn't go below lowest
                            break;
                        case 'dome':
                            yOffset = lowest + (1 - (distanceToCenter * distanceToCenter) / (Math.max(centerX, centerY)**2 * 2)) * (highest - lowest);
                            yOffset = Math.min(yOffset, highest); // Ensure it doesn't go above highest
                            break;
                        case 'wavefront':
                            yOffset = heightMidpoint + Math.sin(deltaX * 0.5) * heightAmplitude;
                            break;
                        case 'random':
                            yOffset = Math.random() * (highest - lowest) + lowest;
                            break;
                        default:
                            yOffset = highest;
                    }

                    // Clamp yOffset to ensure it stays within lowest and highest bounds
                    yOffset = THREE.MathUtils.clamp(yOffset, lowest, highest);

                    const clone = pendantModel.clone();
                    clone.scale.set(PENDANT_SCALE, PENDANT_SCALE, PENDANT_SCALE);
                    clone.position.set(offsetX + c * spacing, yOffset, offsetZ + r * spacing);
                    clone.userData.isPendant = true; // Mark objects for easy removal
                    scene.add(clone);

                    // Create and position the string
                    const stringTopY = surfaceMesh.position.y;
                    const stringHeight = stringTopY - yOffset;
                    const string = new THREE.Mesh(
                        new THREE.CylinderGeometry(STRING_RADIUS, STRING_RADIUS, stringHeight, STRING_SEGMENTS),
                        new THREE.MeshStandardMaterial({ color: STRING_COLOR })
                    );
                    string.position.set(clone.position.x, yOffset + stringHeight / 2, clone.position.z);
                    scene.add(string);
                    pendantStrings.push(string);
                }
            }

            // --- Add Dimension Lines ---
            // Width (X-axis)
            createDimensionLine(
                new THREE.Vector3(-surfaceWidth / 2, objHeight + surfaceHeight + 20, 0),
                new THREE.Vector3(surfaceWidth / 2, objHeight + surfaceHeight + 20, 0),
                `${surfaceWidth.toFixed(0)} mm (Width)`
            );
            // Length (Z-axis)
            createDimensionLine(
                new THREE.Vector3(-surfaceWidth / 2 - 20, objHeight + surfaceHeight, -surfaceLength / 2),
                new THREE.Vector3(-surfaceWidth / 2 - 20, objHeight + surfaceHeight, surfaceLength / 2),
                `${surfaceLength.toFixed(0)} mm (Length)`
            );
            // Height (Y-axis)
            createDimensionLine(
                new THREE.Vector3(surfaceWidth / 2 + 20, 0, surfaceLength / 2),
                new THREE.Vector3(surfaceWidth / 2 + 20, objHeight + surfaceHeight, surfaceLength / 2),
                `${(objHeight + surfaceHeight).toFixed(0)} mm (Total Height)`
            );
        });

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update(); // Only call this once per frame

            // Update positions of all dimension labels
            dimensionLabels.forEach((labelDiv, index) => {
                const { line, start, end } = dimensionLines[index];
                const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                midpoint.project(camera);

                const x = (midpoint.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-midpoint.y * 0.5 + 0.5) * window.innerHeight;

                labelDiv.style.left = `${x}px`;
                labelDiv.style.top = `${y}px`;
            });

            renderer.render(scene, camera);
        }
        animate(); // Start the animation loop

        // --- Event Listeners for UI Controls ---
        // Synchronize range and number inputs
        function setupInputSync(rangeId, numberId) {
            const range = document.getElementById(rangeId);
            const number = document.getElementById(numberId);
            range.addEventListener('input', () => number.value = range.value);
            number.addEventListener('input', () => range.value = number.value);
        }

        setupInputSync('rowsRange', 'rows');
        setupInputSync('columnsRange', 'columns');
        setupInputSync('surfaceLengthRange', 'surfaceLength');
        setupInputSync('surfaceWidthRange', 'surfaceWidth');
        setupInputSync('surfaceHeightRange', 'surfaceHeight');
        setupInputSync('spacingRange', 'spacing');
        setupInputSync('lowestRange', 'lowest');
        setupInputSync('highestRange', 'highest');

        // Hamburger menu toggle
        hamburger.addEventListener('click', () => {
            const isHidden = controlsPanel.style.display === 'none';
            controlsPanel.style.display = isHidden ? 'block' : 'none';
            hamburger.classList.toggle('active', isHidden);
        });

        // Initial state for smaller screens
        if (window.innerWidth < 768) {
            controlsPanel.style.display = 'none';
        }
    </script>
</body>

</html>